---
description: Complete database update workflow - schema, migration, API routes, SDK, and publishing
allowed_tools:
  - Read
  - Write
  - Edit
  - MultiEdit
  - Bash
  - TodoWrite
---

# Database Update Workflow for @cartel-sh/api

This command orchestrates a complete database update including schema changes, migrations, API routes, SDK updates, and optional npm publishing.

## Current Project Structure
- **Database**: PostgreSQL with Drizzle ORM
- **Schema**: `src/schema.ts` - Contains all table definitions and TypeScript interfaces
- **Migrations**: `src/migrations/` - SQL migration files generated by Drizzle Kit
- **API Routes**: `src/server/routes/` - Hono-based REST API endpoints with OpenAPI documentation
- **OpenAPI**: Uses `@hono/zod-openapi` for automatic API documentation generation
- **SDK Client**: `src/client/sdk.ts` - TypeScript SDK for API consumption
- **Build**: TypeScript compilation via tsup to dist/

## Task: Database Schema and API Update

$ARGUMENTS

### Step 1: Analyze Requirements & Plan Changes

First, understand what needs to be added/modified:
- New tables or columns needed
- Relationships between tables
- API endpoints required
- SDK methods to expose

Use TodoWrite to create a detailed task list for the update.

### Step 2: Update Database Schema

Edit `src/schema.ts` to add/modify:

1. **Table Definitions** using Drizzle's pgTable:
```typescript
export const newTable = pgTable("table_name", {
  id: uuid("id").primaryKey().defaultRandom(),
  // Add columns based on requirements
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
}, (table) => {
  return {
    // Add indexes if needed
    someIdx: index("table_name_field_idx").on(table.fieldName),
  };
});
```

2. **Relations** if connecting to other tables:
```typescript
export const newTableRelations = relations(newTable, ({ one, many }) => ({
  // Define relationships
}));
```

3. **TypeScript Interfaces**:
```typescript
export interface NewTable extends InferSelectModel<typeof newTable> {}
export interface NewNewTable extends InferInsertModel<typeof newTable> {}
```

### Step 3: Generate Migration

Run Drizzle Kit to generate the migration SQL:
```bash
bun run generate
```

This creates a new migration file in `src/migrations/`.

### Step 4: Prompt for Migration Execution

⚠️ **IMPORTANT**: Database migrations modify the production schema. 

Tell the user:
"Migration file generated at `src/migrations/[timestamp]_[name].sql`. Please review the migration and run:
```bash
bun run migrate
```
to apply changes to your database. Let me know when complete."

### Step 5: Create/Update API Routes with OpenAPI Documentation

Create a new route file in `src/server/routes/` or update existing ones using OpenAPI:

```typescript
import { createRoute, OpenAPIHono, z } from "@hono/zod-openapi";
import { db } from "../../client";
import { newTable } from "../../schema";
import { eq, and, desc } from "drizzle-orm";

const app = new OpenAPIHono();

// Define validation schemas
const createSchema = z.object({
  // Add fields matching your table structure
});

// Define OpenAPI routes with proper documentation
const listRoute = createRoute({
  method: "get",
  path: "/",
  description: "List all items with optional filtering", // Full sentence description
  summary: "List items", // 2-4 word summary
  request: {
    query: z.object({
      limit: z.coerce.number().optional(),
      offset: z.coerce.number().optional(),
    }),
  },
  responses: {
    200: {
      description: "List of items",
      content: {
        "application/json": {
          schema: z.array(z.object({
            id: z.string(),
            // Add other fields
            createdAt: z.string().nullable(),
            updatedAt: z.string().nullable(),
          })),
        },
      },
    },
    500: {
      description: "Internal server error",
      content: {
        "application/json": {
          schema: z.object({
            error: z.string(),
          }),
        },
      },
    },
  },
  tags: ["NewResource"], // Group related endpoints
});

app.openapi(listRoute, async (c) => {
  const { limit = 50, offset = 0 } = c.req.valid("query");
  
  try {
    const results = await db
      .select()
      .from(newTable)
      .limit(limit)
      .offset(offset);
    
    // IMPORTANT: Always specify status code explicitly for @hono/zod-openapi
    return c.json(results, 200);
  } catch (error) {
    console.error("Error listing items:", error);
    return c.json({ error: "Failed to list items" }, 500);
  }
});

const createRoute = createRoute({
  method: "post",
  path: "/",
  description: "Create a new item in the database",
  summary: "Create item",
  request: {
    body: {
      content: {
        "application/json": {
          schema: createSchema,
        },
      },
    },
  },
  responses: {
    201: {
      description: "Item created successfully",
      content: {
        "application/json": {
          schema: z.object({
            id: z.string(),
            // Include all fields returned
          }),
        },
      },
    },
    400: {
      description: "Invalid request data",
      content: {
        "application/json": {
          schema: z.object({
            error: z.string(),
          }),
        },
      },
    },
    500: {
      description: "Internal server error",
      content: {
        "application/json": {
          schema: z.object({
            error: z.string(),
          }),
        },
      },
    },
  },
  tags: ["NewResource"],
});

app.openapi(createRoute, async (c) => {
  const data = c.req.valid("json");
  
  try {
    const [result] = await db
      .insert(newTable)
      .values(data)
      .returning();
    
    if (!result) {
      return c.json({ error: "Failed to create item" }, 500);
    }
    
    return c.json(result, 201);
  } catch (error) {
    console.error("Error creating item:", error);
    return c.json({ error: "Failed to create item" }, 500);
  }
});

// Add other CRUD operations following the same pattern

export default app;
```

**Important OpenAPI Guidelines:**
1. **Always use `createRoute()`** from `@hono/zod-openapi` instead of plain `app.get()`, `app.post()`, etc.
2. **Include both `description` and `summary`** for every route:
   - `description`: Complete sentence explaining what the endpoint does
   - `summary`: Short 2-4 word title
3. **Define all possible response codes** (200, 400, 404, 500, etc.) with proper schemas
4. **Always specify status codes explicitly** in `c.json()` calls (e.g., `c.json(data, 200)`)
5. **Use proper tags** to group related endpoints in the documentation
6. **Match response schemas exactly** to what your handler returns to avoid TypeScript errors

### Step 6: Register Routes in Main Server

Update `src/server/index.ts`:

1. Import the new route:
```typescript
import newRoute from "./routes/path/to/route";
```

2. Register the route:
```typescript
app.route("/api/path", newRoute);
```

3. Update the root endpoint list if needed.

### Step 7: Update SDK Client

Add corresponding methods to `src/client/sdk.ts`:

```typescript
// Add methods following the existing pattern
async createNewItem(data: Omit<NewTable, 'id' | 'createdAt' | 'updatedAt'>) {
  return this.request("/api/path", {
    method: "POST",
    body: JSON.stringify(data),
  });
}

async getNewItems(params?: { filter?: string }) {
  const query = params ? `?${new URLSearchParams(params).toString()}` : "";
  return this.request(`/api/path${query}`);
}

// Add other SDK methods as needed
```

### Step 8: Test TypeScript Types and Build

First, verify TypeScript compilation:
```bash
bun run typecheck
```

If you encounter type errors with `@hono/zod-openapi`, ensure:
- All `c.json()` calls have explicit status codes
- Response schemas match exactly what handlers return
- Nullable fields are properly marked with `.nullable()`

Then build the project:
```bash
bun run build
```

Verify the build succeeds and check for any TypeScript errors.

### Step 9: Update Version (if publishing)

If changes should be published to npm, update `package.json`:

1. Increment version following semver:
   - Patch (x.x.1): Bug fixes
   - Minor (x.1.0): New features (backwards compatible)
   - Major (1.0.0): Breaking changes

```bash
npm version patch # or minor/major
```

### Step 10: Publish to npm (optional)

If ready to publish:
```bash
npm publish
```

This will run `prepublishOnly` script (build) and publish to npm registry.

## Verification Checklist

After completing the update:
- [ ] Schema changes are properly typed
- [ ] Migration file generated and reviewed
- [ ] Database migrated successfully
- [ ] API routes have OpenAPI documentation (description, summary, tags)
- [ ] All `c.json()` calls have explicit status codes
- [ ] Response schemas match handler return types
- [ ] TypeScript compilation passes (`bun run typecheck`)
- [ ] API documentation available at `/docs` endpoint
- [ ] API routes tested with sample requests
- [ ] SDK methods work correctly
- [ ] Build completes without errors
- [ ] Version updated if publishing
- [ ] Package published to npm if needed

## Common Patterns in This Codebase

### Authentication
- API uses API key authentication via `X-API-Key` header
- Middleware: `src/server/middleware/auth.ts`
- Keys stored in `api_keys` table with SHA-256 hashing
- JWT tokens for session-based auth (SIWE)

### OpenAPI Route Structure
- All routes use `@hono/zod-openapi` with `createRoute()`
- Every route must have:
  - `description`: Full sentence explaining the endpoint
  - `summary`: 2-4 word title
  - `tags`: Array for grouping endpoints
  - Complete response schemas for all status codes
- Handlers must use `app.openapi()` instead of plain HTTP methods
- **Critical**: Always specify status codes in `c.json()` calls

### TypeScript Type Safety
- `@hono/zod-openapi` v1.1.0 has strict type checking
- Response schemas must exactly match handler returns
- Use `.nullable()` for optional database fields
- Convert Date objects to ISO strings for JSON responses
- Status codes must be explicit: `c.json(data, 200)`

### Database Queries
- Use Drizzle ORM query builder
- Transactions for multi-table operations
- Proper indexes for performance
- Handle nullable fields appropriately

### SDK Pattern
- Private `request` method handles auth
- Public methods for each endpoint
- TypeScript types from schema
- Error handling with descriptive messages

### API Documentation
- OpenAPI spec auto-generated at `/openapi.json`
- Interactive docs available at `/docs` (Scalar UI)
- Markdown docs at `/llms.txt` for LLM consumption

## Troubleshooting OpenAPI TypeScript Errors

### Common Type Error: "Argument of type ... is not assignable to parameter of type Handler"
**Cause**: Response schemas don't match handler return types or missing status codes
**Solutions**:
1. Add explicit status codes to all `c.json()` calls
2. Ensure response schemas match exactly what's returned
3. Mark nullable fields with `.nullable()` in schemas

### Example Fix:
```typescript
// ❌ Wrong - no status code
return c.json(data);

// ✅ Correct - explicit status code
return c.json(data, 200);

// ❌ Wrong - schema doesn't match nullables
schema: z.object({
  status: z.string(), // But DB returns null sometimes
})

// ✅ Correct - nullable field
schema: z.object({
  status: z.string().nullable(),
})
```

### Converting Existing Routes to OpenAPI
When converting plain Hono routes to OpenAPI:
1. Replace `app.get()` with `createRoute()` + `app.openapi()`
2. Add description, summary, and tags
3. Define request/response schemas
4. Add explicit status codes to all returns
5. Test with `bun run typecheck`

## Notes

- SDK is published as `@cartel-sh/api` on npm
- OpenAPI documentation greatly improves developer experience
- TypeScript strict mode is required for proper type checking
- Always test API changes with the interactive docs at `/docs`