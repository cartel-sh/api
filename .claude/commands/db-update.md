---
description: Complete database update workflow - schema, migration, API routes, SDK, and publishing
allowed_tools:
  - Read
  - Write
  - Edit
  - MultiEdit
  - Bash
  - TodoWrite
---

# Database Update Workflow for @cartel-sh/api

This command orchestrates a complete database update including schema changes, migrations, API routes, SDK updates, and optional npm publishing.

## Current Project Structure
- **Database**: PostgreSQL with Drizzle ORM
- **Schema**: `src/schema.ts` - Contains all table definitions and TypeScript interfaces
- **Migrations**: `src/migrations/` - SQL migration files generated by Drizzle Kit
- **API Routes**: `src/server/routes/` - Hono-based REST API endpoints
- **SDK Client**: `src/client/sdk.ts` - TypeScript SDK for API consumption
- **Build**: TypeScript compilation via tsup to dist/

## Task: Database Schema and API Update

$ARGUMENTS

### Step 1: Analyze Requirements & Plan Changes

First, understand what needs to be added/modified:
- New tables or columns needed
- Relationships between tables
- API endpoints required
- SDK methods to expose

Use TodoWrite to create a detailed task list for the update.

### Step 2: Update Database Schema

Edit `src/schema.ts` to add/modify:

1. **Table Definitions** using Drizzle's pgTable:
```typescript
export const newTable = pgTable("table_name", {
  id: uuid("id").primaryKey().defaultRandom(),
  // Add columns based on requirements
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).defaultNow(),
}, (table) => {
  return {
    // Add indexes if needed
    someIdx: index("table_name_field_idx").on(table.fieldName),
  };
});
```

2. **Relations** if connecting to other tables:
```typescript
export const newTableRelations = relations(newTable, ({ one, many }) => ({
  // Define relationships
}));
```

3. **TypeScript Interfaces**:
```typescript
export interface NewTable extends InferSelectModel<typeof newTable> {}
export interface NewNewTable extends InferInsertModel<typeof newTable> {}
```

### Step 3: Generate Migration

Run Drizzle Kit to generate the migration SQL:
```bash
bun run generate
```

This creates a new migration file in `src/migrations/`.

### Step 4: Prompt for Migration Execution

⚠️ **IMPORTANT**: Database migrations modify the production schema. 

Tell the user:
"Migration file generated at `src/migrations/[timestamp]_[name].sql`. Please review the migration and run:
```bash
bun run migrate
```
to apply changes to your database. Let me know when complete."

### Step 5: Create/Update API Routes

Create a new route file in `src/server/routes/` or update existing ones:

```typescript
import { Hono } from "hono";
import { z } from "zod";
import { zValidator } from "@hono/zod-validator";
import { db } from "../../db";
import { newTable } from "../../schema";
import { eq, and, desc } from "drizzle-orm";

const app = new Hono();

// Define validation schemas
const createSchema = z.object({
  // Add fields
});

// GET endpoints
app.get("/", async (c) => {
  const results = await db.select().from(newTable);
  return c.json(results);
});

// POST endpoints
app.post("/", zValidator("json", createSchema), async (c) => {
  const data = c.req.valid("json");
  const [result] = await db.insert(newTable).values(data).returning();
  return c.json(result);
});

// Add other CRUD operations as needed

export default app;
```

### Step 6: Register Routes in Main Server

Update `src/server/index.ts`:

1. Import the new route:
```typescript
import newRoute from "./routes/path/to/route";
```

2. Register the route:
```typescript
app.route("/api/path", newRoute);
```

3. Update the root endpoint list if needed.

### Step 7: Update SDK Client

Add corresponding methods to `src/client/sdk.ts`:

```typescript
// Add methods following the existing pattern
async createNewItem(data: Omit<NewTable, 'id' | 'createdAt' | 'updatedAt'>) {
  return this.request("/api/path", {
    method: "POST",
    body: JSON.stringify(data),
  });
}

async getNewItems(params?: { filter?: string }) {
  const query = params ? `?${new URLSearchParams(params).toString()}` : "";
  return this.request(`/api/path${query}`);
}

// Add other SDK methods as needed
```

### Step 8: Build the Project

Run the build command to compile TypeScript:
```bash
bun run build
```

Verify the build succeeds and check for any TypeScript errors.

### Step 9: Update Version (if publishing)

If changes should be published to npm, update `package.json`:

1. Increment version following semver:
   - Patch (x.x.1): Bug fixes
   - Minor (x.1.0): New features (backwards compatible)
   - Major (1.0.0): Breaking changes

```bash
npm version patch # or minor/major
```

### Step 10: Publish to npm (optional)

If ready to publish:
```bash
npm publish
```

This will run `prepublishOnly` script (build) and publish to npm registry.

## Verification Checklist

After completing the update:
- [ ] Schema changes are properly typed
- [ ] Migration file generated and reviewed
- [ ] Database migrated successfully
- [ ] API routes tested with sample requests
- [ ] SDK methods work correctly
- [ ] Build completes without errors
- [ ] Version updated if publishing
- [ ] Package published to npm if needed

## Common Patterns in This Codebase

### Authentication
- API uses API key authentication via `X-API-Key` header
- Middleware: `src/server/middleware/auth.ts`
- Keys stored in `api_keys` table with SHA-256 hashing

### Route Structure
- All routes use Hono framework
- Validation with Zod schemas
- Error handling via try-catch
- JSON responses

### Database Queries
- Use Drizzle ORM query builder
- Transactions for multi-table operations
- Proper indexes for performance

### SDK Pattern
- Private `request` method handles auth
- Public methods for each endpoint
- TypeScript types from schema
- Error handling with descriptive messages

## Notes

- SDK is published as `@cartel-sh/api` on npm